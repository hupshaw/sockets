from socket import * 
from struct import pack, unpack

class BufferedTCPEchoServer(object):
    def __init__(self, host = '', port = 36001, buffer_size = 1024):
        # Save the buffer size to a variable. You'll need this later
        self.buffer_size = buffer_size

        # This variable is used to tell the server when it should shut down. Our implementation of this server is centered
        # around one or more while loops that keeps the server listening for new connection requests and new messages from
        # a connected client. This should continue forever, or until this self.keep_running is set to False. My testing
        # code will use self.keep_running to shutdown the server for one test case 
        self.keep_running = True

        # Create and bind the server socket
        self.server_sock = socket(AF_INET, SOCK_STREAM)
        self.server_sock.bind((host, port))

    def buffer_recv():
        pass

    # This function starts the server listening for new connections and new messages. It initiates the core loop of our 
    # server, where we loop continuously listening for a new connection, or if we are already connected, listening for a new 
    # message. I recommend breaking the functionality up into helper functions
    # Remember that this server can only talk to one connected client at a time. We'll implement a server that
    # can connect to multiple clients at once in a future project.
    # TODO: 
    # * On disconnect, attempt to accept a new connection
    #       * This process should continue until self.keep_running is set to False. (The program doesn't need immediately close when the value changes)
    #       * Shutdown the server's socket before exiting the program
    def start(self):
        print('SERVER: listening...')
        while self.keep_running:
            
            self.server_sock.listen(1) 
            new_sock, client_addr = self.server_sock.accept() 
            
            # Get Data
            data = new_sock.recv(self.buffer_size)
            length = data[:2]
            length = unpack("!H", length)[0]
            print(length)
            payload = data[2:]
            while len(payload) < length:
                data = new_sock.recv(self.buffer_size)
                payload += data
            message = payload.decode()[10:]
            print(message)
            message_length = len(message)
            packed_data = pack("!H"+str(message_length)+"s", message_length, message.encode())
            new_sock.send(packed_data)
            self.keep_running = False
            #remove before submission so the loop can repeat


    # This method is called by the autograder when it is ready to shut down your program. You should clean up your server socket
    # here. Note that all other sockets opened by the server also need to be closed once you are done with them. You should be closing
    # the individual client sockets generated by socket.accept() inside of your start() function 
    def shutdown(self):
        print("SERVER: shutting down...")
        self.server_sock.close()


if __name__ == "__main__":
    BufferedTCPEchoServer(host='', port=36001, buffer_size=1024).start()
    